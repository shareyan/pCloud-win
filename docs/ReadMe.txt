本文的主要目的是方便想要加入开发的人快速的了解整个程序的结构

基本环境介绍
	这个程序前端是由visual studio 开发，没有采用MFC，全是用的API，本人也是第一次做windows 图形化程序，看网上说MFC各种渣。
	于是就没有采用MFC。但是实际开发起来才觉得被坑了。MFC可能封装的并不好，但自己从最基础的api开始做果然还是太原始，太底层了。比如想要显示一个tip都很困难。
	后台程序是用node.js开发，原因是node的环境比较小，开发起来也很灵活。不能用node实现的部分用c++进行编程。比如播放声音。

基本思路
	现主要介绍一下程序干了什么事情，然后说一下程序的设计思路，最后说哪一部分程序干了什么事情

程序的基本流程
	程序基本上可以分成两个部分，windows前端和node后台。前端程序位于src/Winfly.exe。
	前端启动后会启动node程序
		然后每100ms读取一次port.txt文件，如果文件内容是0，那么就继续等待读取
		读取到不为0的端口号后，向这个端口发送命令获取，版本信息，等等
		以后每一秒会发送一个获取信息指令，如果后台有想通知前台的消息就可以在这里返回
	node程序启动后 
		读取数据库文件
			数据库文件在是models/db，实际上是json然后利用本机mac进行加密后存储
			mac信息加密之后放在key文件里面，如果检测到mac和key无法对应，就删除整个数据库。
		启动应用
			载入模板文件
				模板文件在views文件夹内。程序会把这个文件夹内的文件全部读出来，然后存在一个数组里面。这样做是为了减少io操作，增加执行效率
			获取一个空的端口，在此端口监听http请求，这个就是浏览器访问的端口
				端口获取成功之后会上传本机的ip和http监听端口
			获取一个空的端口，在此端口监听tcp socket，这个是用来和前端程序通信用的
				端口获取成功之后把端口号写入到port.txt。前端程序之后会和这个端口进行通信
				node程序会根据收到的信息执行不同的程序
		http请求的处理
			这一部分在程序结构里面再说
		程序退出时
			程序退出时会把程序当前需要保存的重要变量加密后存到数据库文件内
	服务器端
		服务器主要有两个功能
		当收到node程序发送的更新ip请求时，更新对应账户的ip
		当浏览器输入指定地址的时候，根据地址和记录的ip端口信息跳转到对应的电脑
	更新过程
		前端程序启动和后台成功通信后，会向后台发送update指令，后台收到这个指令后会检测本地版本和服务器上的最新版本号。如果不同就开始更新程序
		请求自己对应版本号的json文件，这个文件内列出了要更新的文件。更新程序根据文件列表下载相应的文件替换本地文件。更新程序单独开了一个进程。在替换前会向后台程序发送退出指令。等待程序退出完成之后开始替换本地程序文件。文件替换完成之后再启动前端程序。启动完成后退出。

程序的基本结构
	程序的基本设计思路是MVC模型。数据模型model，显示的view和控制的control。文件夹的设置也是按照这个。
	由于现有的node网络架构太大了，为了控制大小我自己实现了一个简单的架构。
	网络请求来了之后
		创建一个app对象，这个对象对基本的方法进行了封装，比如返回http相应，渲染模板，返回json，设置cookie，session和user
		创建app的时候把数据库模板，网络请求和相应全部封装在app里面。以后函数的处理对象也就全是app
		判断url
			如果url是static开头那么就把请求给静态文件处理程序处理
			如果是share开头，就把请求处理之后给静态文件处理程序处理。share就是你共享的文件夹
		开始中间层程序
			中间层主要是对一些底层的东西进行处理，比如说session和user。也就是在作为view进行处理之前要处理的东西
		开始路由程序
			路由程序做的是根据请求的url调用不同的处理函数
			从路由跳转到相应的处理程序之后，程序进行处理然后返回响应
		
	架构的基本介绍
		实际上就是对底层的操作进行封装，文件在utils/syFrm.js
		具体的封装直接看函数就很清楚了
	models
		models采用ORM的思想，所以在所有的model里面都包含了一些通用的方法。理想的做法应该是把这些做成一个类然后由各个model去继承，但是实际上由于刚开始做的时候
		没有考虑这么多现在的model的方法都是重复的写了好几遍。通用的方法是以object开头。下面举一个创建对象的例子
		var myUser = User(app)//创建一个user 对象
		myUser.name = 'userA'//设置对象属性
		myUser.objects.save()//保存对象到数据库 这里并没有把数据保存到文件之中，而是在内存中，只有在程序退出时才会保存至数据库文件。
		
		var myUser = User(app)
		myUser = myUser.objects.get('userA')//从内存读取用户名为userA的对象 这时候就可以访问对象的各个属性了
		
	views
		渲染
			前端模板的渲染采用juicer，后台的渲染是whisker。后台的渲染工作主要是把重要的数据渲染到前端 js的变量里面，真正进行DOM操作的是前端的模板。
			前端的渲染只要在updateView()函数里面，想要更新网页只要把相应的变量修改之后然后调用updateView()就可以了。
			实际上我的设计思路是想在前端同样实现一个MVC的结构，数据部分由服务器提供保存在变量之中。只要改变量然后调updateView()就可以更新网页内容了。
	middleware
		在请求真正交给control处理之前，要经过middleware进行处理。如果你有对于所有的请求都要进行的操作就可以加在middleware中进行处理。比如说统计网页总的浏览量，
		统计在线用户情况。现在的middleware实际上做了两件事情，session 处理了和session有关的的操作，比如说用户登陆。user 是根据有没有注册管理员进行跳转。
	controls
		控制的部分没什么特别的以一个例子来说明一个控制程序的基本结构
		function example(app){
			return app.JSON({'message':'OK'});
		}
		req和res都被封装在app之中，所以一般情况下不需要直接操作req和res。想要返回相应直接return app的方法就行了
	
		
程序的文件结构和具体实现
	/logs
		这个文件夹内是程序的运行信息，port.txt是用来前台和后台进行通信用的
	/src
		程序的主要内容
		/bin
			系统相关的文件，现在里面是一个用来播放wav的exe
		/pCloud
			/config
				基本的配置文件。configs.js 是版本号和域名信息，route.js就是路由设置文件 
			/controls
				控制文件，路由文件会根据url调用控制里面的js。middleware就是之前说的中间层文件
			/models
				数据模型文件和数据库文件。这里实际上没有用到数据库数据的存储只是存到了文件里面 。同样是为了减小大小考虑的
			/public
				静态文件文件夹，包含css，js，img
			/utils
				工具函数文件夹，包含了一些底层的函数，比如说加密算法，读取文件，更新ip，获取mac等等
			/views
				渲染用的html文件
			app.js
				node的主要启动文件
		/resource
			资源文件，比如声音什么的
		Winfly.exe
			前端程序文件
	/updates
		更新程序所需要的内容
	/docs
		程序开发说明文档